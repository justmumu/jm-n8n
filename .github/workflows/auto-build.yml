name: Auto Build Custom n8n with Other Tools

on:
  schedule:
    - cron: '0 3 * * *' # Runs daily at 03:00 UTC
  workflow_dispatch: # Manual trigger

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Job 1: Check for new n8n version
  check-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.n8n_version.outputs.version }}
      alpine_version: ${{ steps.alpine_version.outputs.version }}
      should_build: ${{ steps.check_image.outputs.should_build }}
    
    steps:
      - name: Get latest n8n version
        id: n8n_version
        run: |
          # Get the digest of the 'latest' tag
          LATEST_DIGEST=$(curl -s "https://hub.docker.com/v2/repositories/n8nio/n8n/tags/latest" | jq -r '.images[0].digest')
          echo "Latest tag digest: $LATEST_DIGEST"
          
          # Find the version tag with the same digest
          VERSION=$(curl -s "https://hub.docker.com/v2/repositories/n8nio/n8n/tags?page_size=100" \
            | jq -r --arg digest "$LATEST_DIGEST" \
            '.results[] | select(.images[0].digest == $digest) | .name' \
            | grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' \
            | head -1)
          echo "Detected latest n8n version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Get Alpine version from n8n image
        id: alpine_version
        run: |
          ALPINE_VER=$(docker run --rm --entrypoint sh n8nio/n8n:${{ steps.n8n_version.outputs.version }} -c "grep VERSION_ID /etc/os-release | cut -d= -f2")
          echo "Detected Alpine version: $ALPINE_VER"
          echo "version=$ALPINE_VER" >> $GITHUB_OUTPUT

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if image already exists
        id: check_image
        run: |
          if docker manifest inspect ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.n8n_version.outputs.version }} > /dev/null 2>&1; then
            echo "should_build=false" >> $GITHUB_OUTPUT
            echo "Image already exists, skipping build."
          else
            echo "should_build=true" >> $GITHUB_OUTPUT
            echo "New version detected, will build."
          fi

  # Job 2: Build images in parallel (matrix strategy with native runners)
  build:
    needs: check-version
    if: needs.check-version.outputs.should_build == 'true'
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract platform suffix
        id: platform
        run: |
          PLATFORM="${{ matrix.platform }}"
          SUFFIX="${PLATFORM#linux/}"
          echo "suffix=$SUFFIX" >> $GITHUB_OUTPUT

      - name: Build and push platform image
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: ${{ matrix.platform }}
          provenance: false
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-version.outputs.version }}-${{ steps.platform.outputs.suffix }}
          build-args: |
            N8N_VERSION=${{ needs.check-version.outputs.version }}
            ALPINE_VERSION=${{ needs.check-version.outputs.alpine_version }}
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache-${{ steps.platform.outputs.suffix }}
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:cache-${{ steps.platform.outputs.suffix }},mode=max

  # Job 3: Create multi-platform manifest
  create-manifest:
    needs: [check-version, build]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    steps:
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push manifest for version tag
        run: |
          docker manifest create ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-version.outputs.version }} \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-version.outputs.version }}-amd64 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-version.outputs.version }}-arm64
          docker manifest push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-version.outputs.version }}

      - name: Create and push manifest for latest tag
        run: |
          docker manifest create ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-version.outputs.version }}-amd64 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-version.outputs.version }}-arm64
          docker manifest push ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest

      - name: Cleanup platform-specific tags (optional)
        continue-on-error: true
        run: |
          echo "Platform-specific images kept for cache purposes"
          echo "  - ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-version.outputs.version }}-amd64"
          echo "  - ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.check-version.outputs.version }}-arm64"
